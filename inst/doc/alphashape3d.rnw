%\VignetteIndexEntry{R Implementation of a Polyhedral Approximation to a 3D Set of Points Using the alpha-shape}
%\VignetteDepends{geometry, rgl}
%\VignetteKeywords{package}
%\VignettePackage{alphashape3d}


\documentclass[nojss]{jss}

\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{bm}
\usepackage{graphicx}               
\usepackage{pstricks,pst-plot}
\usepackage{upgreek}

\newtheorem{definition}{Definition}[section]
\newtheorem{remark}{Remark}[section]
\newtheorem{lemma}{Lemma}[section]

%\SweaveOpts{prefix.string=Figures/jss957fig}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% declarations for jss.cls %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% almost as usual
\author{Thomas Lafarge\\ National Institute of Standards and Technology
\AND
Beatriz Pateiro-L\'{o}pez\\ Universidad de Santiago de Compostela
\AND
Antonio Possolo\\ National Institute of Standards and Technology
\AND
Joy P. Dunkers\\ National Institute of Standards and Technology}

\title{\proglang{R} Implementation of a Polyhedral Approximation
  to a 3D Set of Points Using the $\bm{\alpha}$-shape}

%% for pretty printing and a nice hypersummary also set:
\Plainauthor{Thomas Lafarge, Beatriz Pateiro-L\'{o}pez, Antonio
  Possolo, Joy P. Dunkers} %% comma-separated
%%AMP
\Plaintitle{R implementation of a polyhedral approximation
  to a 3D set of points using the
  \alpha-shape} %% without formatting
\Shorttitle{The \pkg{alphashape3d} package} %% a short title (if necessary)

%% an abstract and keywords
\Abstract{
This introduction to the \proglang{R} package \pkg{alphashape3d} is a (slightly)
modified version of \cite{laf2014}, published in the
\emph{Journal of Statistical Software}.
This work presents the implementation in \proglang{R}
  of the $\alpha$-shape of a finite set of points in the
  three--dimensional space $\mathbb{R}^3$. This geometric
  structure generalizes the convex hull and allows to recover the
  shape of non--convex and even non--connected sets in 3D, given
  a random sample of points taken into it. Besides the
  computation of the $\alpha$-shape, the \proglang{R} package
  \pkg{alphashape3d} provides users with tools to facilitate the
  three--dimensional graphical visualization of the estimated
  set as well as the computation of important characteristics such as the connected components or the volume, among others.}
  
\Keywords{set estimation, 3D surface reconstruction, $\alpha$-convexity,  $\alpha$-shape, \proglang{R} software}
\Plainkeywords{3D surface reconstruction, alpha--convexity,  alpha--shape, alpha--convex hull, R software} %% without formatting
%% at least one keyword must be supplied

%% publication information
%% NOTE: Typically, this can be left commented and will be filled out by the technical editor
%% \Volume{13}
%% \Issue{9}
%% \Month{September}
%% \Year{2004}
%% \Submitdate{2004-09-29}
%% \Acceptdate{2004-09-29}

%% The address of (at least) one author should be given
%% in the following format:
\Address{
  Beatriz Pateiro-L\'{o}pez. \\
  Departamento de Estad\'{i}stica e Investigaci\'{o}n Operativa\\
  Facultad de Matem\'{a}ticas. R\'{u}a Lope G\'{o}mez de Marzoa s/n\\
  15782 Santiago de Compostela, Spain\\
  E-mail: \email{beatriz.pateiro@usc.es}\\
  %URL: \url{http://statmath.wu-wien.ac.at/~zeileis/}
}
%% It is also possible to add a telephone and fax number
%% before the e-mail in the following format:
%% Telephone: +43/1/31336-5053
%% Fax: +43/1/31336-734

%% for those who use Sweave please include the following line (with % symbols):
%% need no \usepackage{Sweave.sty}

%% end of declarations %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{document}


<<echo=false,results=hide>>=
library(alphahull)
library(rgl)
library(geometry)
#library(penalizedSVM)
library(alphashape3d)
options(prompt = "R> ", continue = "+  ")
@

\section[Introduction]{Introduction}
Point sets are a fundamental source of information in many
disciplines: they may be samples from probability distributions,
portions of realizations of point processes observed within
bounded sampling windows, or have substantive meaning (for
example, landmarks in industrial parts or in biological
structures). In many cases, a primary goal is to recover the size
and shape of the set the points originate from (set
estimation). In some applications the set is known but a sample
of points is taken from it anyway, and used as a discrete
approximation that facilitates the estimation of selected
geometric attributes of the set (morphometry).

Besides the long-standing models for two-dimensional (2D) data,
there is now an increasing interest in modeling techniques for
three-dimensional (3D) data. Widely available technologies for
measurement of 3D structures --- including 3D laser-scanning,
confocal microscopy, and computed tomography from nano to macro
scales --- are generating high-quality digital datasets that may
be point clouds, or sets whose geometry can be probed using point
clouds, in cellular biology, medicine, material science,
engineering, etc.
Consequently, a rich branch of image analysis has been developing
rapidly to deal with the reconstruction of 3D objects from point
clouds, and to study geometrical attributes after discretization
by sampling with point clouds. 

Statistical morphometry seeks to characterize the variability of
shape and size, which is essential in a wide range of disciplines
that include biology, material science, geology, archaeology,
geography, etc. We refer to \cite{small96} and \cite{grenander-2007} for an extensive
review of the methods and applications of shape analysis. See
also \cite{claude08} for a guide on how to perform morphometrics
with \proglang{R}. The geometric characterization of an object
includes the computation of volumes and surface areas, surface
roughness, deviations from convexity, porosity and permeability,
among many other attributes, in many cases from points sampled
within the object.  In practice, the user defines a sampling
procedure to obtain points in the set of interest, and thus the
problem relates to the problem of set estimation.

The goal of set estimation is to produce estimates of compact
subsets of an Euclidean space based on random samples of points
from probability distributions whose supports are those sets, and
then to study the statistical properties of the corresponding
estimators (asymptotic properties, types of convergence,
convergence rates, etc.). \cite{cuevas09} surveys the most
relevant theory on set estimation.  

There are different geometrical structures that can capture the
shape of a set from a sample of points taken from it. The extent
to which these structures manage faithfully to reproduce the
original set depends heavily on the geometrical characteristics
of the set. For instance, if the original set is convex, the
convex hull of the sample is the natural estimator. See
\cite{Geffroy64}, \cite{Renyi63, Renyi64}, \cite{Schneider88},
\cite{Dumbgen96} for results about the convex hull
estimator. However, in many applications the sets or objects of
interest are not strictly convex, but only approximately
so. There is, therefore, a need to define relaxed convexity shape
restrictions. 

The $\alpha$-convexity is one such restriction that mildly relaxes
the assumption of convexity, and does so in a tunable manner
(determined by the value of the parameter $\alpha$): it appears
in the literature on set estimation, see \cite{Walther97,
  Walther99}, \cite{Rodriguez06}. By analogy with the
characterization of a convex set as the intersection of
half-spaces defined by planes tangent to the set, a set is said
to be $\alpha$-convex if it can be expressed as an intersection
of the complements of open balls of radius $\alpha$ not
intersecting the set. Section \ref{sec:2} provides
details on $\alpha$-convex sets.  The so-called $\alpha$-convex
hull of the sample is a suitable estimator of $\alpha$-convex
sets  (think of what's left if carving out all the
space with a spherical scoop of radius $\alpha$ without removing
any of the points in the sample). \cite{Rodriguez06} studies the asymptotic performance of
this estimator.

The boundary of the $\alpha$-convex hull comprises arcs of
circles (in 2D), or spherical caps (in 3D), and intersections
thereof. If now we approximate the boundary of the
$\alpha$-convex hull by a polygonal curve (in 2D) or
by a polyhedral surface (in 3D), then we get another object that
approximates the original set, called the
$\alpha$-shape. \cite{Edels83} defined it in the case of
$\mathbb{R}^2$, and \cite{Edels94} generalized it to
three-dimensional Euclidean space. The $\alpha$-shapes have been
widely used in several different fields: for example, to
characterize biological systems, and the structure, surface and
cavities of molecules and proteins, as described by
\cite{Liang98, Liang98b}, \cite{Edels95}, \cite{Zhou10}, among others. Also in cosmology, by \cite{weygaert10}, to study the
topology of the distribution of galaxies. \cite{Vauhkonen08}
describe applications of $\alpha$-shapes in remote sensing,
where tree characteristics are determined from laser scanning
data. There are also connections between $\alpha$-shapes and
pattern recognition and clustering techniques. Given a porous
material, the $\alpha$-shape of a sample of points drawn from the
material can be used to characterize the geometry of the pores;
alternatively, the $\alpha$-shape of a sample of points drawn
from the voids can be used to study the permeability of the
material.

It is becoming increasingly clear that \proglang{R}
(\cite{Rcran}) has grown to become one of the most powerful tools
for statistical data analysis, and in fact the \emph{lingua
  franca} for the interchange of ideas and methods in
computational statistics and probability. \proglang{R} is a
high-level language that offers powerful graphical capabilities
and a wide variety of facilities for statistical modeling and
data analysis in many fields of research. Many of the techniques discussed in this paper have been
developed over the last couple of decades, and there exist
several \proglang{R} packages that, in one form or another,
address issues of set estimation.  For example, the convex hull
of a set of points in $d$--dimensional Euclidean space can be
computed using functions in package \pkg{geometry}
\citep{geometry}. Objects analyzed in the disciplines mentioned
above are mostly two-dimensional or three-dimensional. The
two-dimensional $\alpha$-shape and the $\alpha$-convex hull are
implemented in the \proglang{R} package \pkg{alphahull} by
\cite{alphahull}. \cite{Edels83} describe the algorithm for the
computation of the $\alpha$-shape and $\alpha$-convex hull in
2D. \cite{pateiro10} provide further details on the library and
applications. However, and in spite of its potential usefulness
in statistical analysis, the $\alpha$-shape in 3D had not yet
been implemented in \proglang{R}. Cognizant of the importance of
the development of a free, open-source software environment for
statistical computing, we have produced the \proglang{R} package
\pkg{alphashape3d}, see \cite{Lafarge11}.

The paper is organized as follows. In Section \ref{sec:2} we
provide some background in set estimation theory and describe the
estimator under study, the $\alpha$-shape of a random sample of
points in the three-dimensional Euclidean space. In Section
\ref{sec:imp} we briefly describe the algorithm by \cite{Edels94}
and give the details about its implementation in
\proglang{R}. Further
computational details are given in Section
\ref{sec:comp}. 


\section[The alpha-shape in 3D]{The $\bm{\alpha}$-shape in 3D}\label{sec:2}

This work is based on the computation of $\alpha$-shapes in
$\mathbb{R}^3$ as defined by \cite{Edels94}. The $\alpha$-shape
is computationally practicable, and it is closely related to the
$\alpha$-convex hull estimator, which has been studied
predominantly from a theoretical viewpoint. As mentioned in the
Introduction, in order to estimate an unknown set effectively,
from points drawn from it, some geometrical assumptions have to
be made. Even though convex sets have many useful and
  well-known properties, restricting attention to estimators that
  are convex sets rules out consideration of many sets of great
  practical interest.  There are
meaningful extensions of the notion of convexity, such as
$\alpha$-convexity. A set $A\subset \mathbb{R}^d$ is said to be
$\alpha$-convex, for $\alpha>0$, if $A=C_\alpha(A),$
where
\begin{equation}\label{rconvhull}
  C_\alpha(A)=\bigcap_{\{\mathring{B}(x,\alpha):\
    \mathring{B}(x,\alpha)\cap
    A=\emptyset\}}{\left(\mathring{B}(x,\alpha)\right)^c} 
\end{equation}
is called the $\alpha$-convex hull of $A$. In
(\ref{rconvhull}), $\mathring{B}(x,\alpha)$ denotes the open ball
with center $x$ and radius $\alpha$.
\cite{Walther99} describes properties of $\alpha$-convex sets and
relations between convexity and $\alpha$-convexity. Let $S$ be a
nonempty compact subset in $\mathbb{R}^d$, equipped with the norm
$\left\|\cdot\right\|$.  Assume that we are given a random sample
$\mathcal{X}_n=\{X_1,\ldots,X_n\}$ from a probability
distribution $P_X$ on $\mathbb{R}^d$ with support $S$. The goal
is to approximate $S$ based on the sample. If we assume that the
set $S$ is $\alpha$-convex then the natural estimator of $S$ is
$C_\alpha(\mathcal{X}_n)$, the $\alpha$-convex hull of the
sample. \cite{Rodriguez06} characterizes the performance of the
estimator. In Figure~\ref{fig:ahull} we represent the
$\alpha$-convex hull estimator in the two-dimensional case. If we
straighten the $\alpha$-convex hull in Figure~\ref{fig:ahull} by
substituting straight edges for the circular arcs, we obtain a
straight line graph known as $\alpha$-shape: this is
computationally more practicable than the $\alpha$-convex
hull. \cite{Edels83} give a formal definition of the
$\alpha$-shape in $\mathbb{R}^2$.

\begin{figure}[!h]
\begin{center}
\scalebox{1.1}{
<<fig=TRUE,echo=false,results=hide,width=14,height=5>>=lset(col.whitebg())
n<-300
m<-0
data<-matrix(0,n,2)
while(m<n){
x<-runif(1)
y<-runif(1)
if(((x-0.5)^2+(y-0.5)^2<=(0.5)^2 )&((x-0.5)^2+(y-0.5)^2>=(0.25)^2)){
m<-m+1
data[m,]<-c(x,y)
}
}
x<-data
par(mfrow=c(1,3))
alpha1=0.04
alpha2=0.2
alpha3=1
plot(0,type="n",xlim=c(0,1),ylim=c(0,1),xlab="",ylab="",main=expression(paste(alpha," = 0.04 ")),axes=F,cex.main=2.7,asp=TRUE)
axis(1,cex.axis=2.7)
axis(2,cex.axis=2.7)
plot(ahull(x,alpha=alpha1),do.sha=TRUE,wpoints=TRUE,col=c(6,4,rep(1,3)),lwd=2,add=T)
plot(0,type="n",xlim=c(0,1),ylim=c(0,1),xlab="",ylab="",main=expression(paste(alpha," = 0.2 ")),axes=F,cex.main=2.7,asp=TRUE)
axis(1,cex.axis=2.7)
axis(2,cex.axis=2.7)
plot(ahull(x,alpha=alpha2),do.sha=TRUE,wpoints=TRUE,col=c(6,4,rep(1,3)),lwd=2,add=T)
plot(0,type="n",xlim=c(0,1),ylim=c(0,1),xlab="",ylab="",main=expression(paste(alpha," = 1 ")),axes=F,cex.main=2.7,asp=TRUE)
axis(1,cex.axis=2.7)
axis(2,cex.axis=2.7)
plot(ahull(x,alpha=alpha3),do.sha=TRUE,wpoints=TRUE,col=c(6,4,rep(1,3)),lwd=2,add=T)
par(mfrow=c(1,1))
@  
}
\end{center}
\caption{In pink, boundary of the $\alpha$-convex hulls of a uniform random sample of size $n=300$ on a ring in $\mathbb{R}^2$ for different values of $\alpha$. In blue, the corresponding
    $\alpha$-shapes.}
\label{fig:ahull}
\end{figure}

In $\mathbb{R}^3$, one can visualize the $\alpha$-convex hull
estimator by thinking of a sphere of radius $\alpha$ scooping up
space around the points without removing any of them. By
  replacing each spherical cap with the largest triangle
  circumscribed by the cap we obtain the
$\alpha$-shape, see Figure~\ref{fig:ahull3}. The formal
definition of the $\alpha$-shape in 3D can be found in
\cite{Edels94}. It can be computed from the $\alpha$-complex of
the sample, also
  defined in \cite{Edels94}, which is a subcomplex of the Delaunay
triangulation. The $\alpha$-shape is the polytope (in a general
sense) formed by the union of all simplices of the
$\alpha$-complex. Further details are given in Section
\ref{sec:imp}. The value of $\alpha$ controls the spatial scale
of the shape of the estimator. As $\alpha$ decreases, the $\alpha$-shape shrinks and cavities
appear among the sample points. As  $\alpha$ tends to $\infty$,
the $\alpha$-shape tends to the the convex hull of the sample, see Figure~\ref{fig:ahull3}. This emphasizes the fact that the $\alpha$-shape can be considered a generalization of the convex hull.
The flexibility that varying $\alpha$
  affords is very useful to characterize the geometry of porous
  materials. When studying some of the properties of these
  materials, it may be preferable to focus on the $\alpha$-shape
  of the voids: for example, to characterize the geometry of
  tunnels that link different pores, as will be illustrated in
  Section~\ref{sec:app}.



<<echo=FALSE, results=hide>>=
n<-800
n2<-20
t<-runif(n,0,pi/1.2)
x<-sin(6*t)
y<-cos(6*t)
z<-t
x1<-matrix(0,nr=n,ncol=n2)
y1<-matrix(0,nr=n,ncol=n2)
z1<-matrix(0,nr=n,ncol=n2)
for(i in 1:n){
norm<-matrix(rnorm(n2*3),nc=3)
aux<-norm/sqrt(rowSums(norm^2))
r<-runif(n2,0,0.15)
aux<-r*aux
x1[i,]<-aux[,1]+x[i]
y1[i,]<-aux[,2]+y[i]
z1[i,]<-aux[,3]+z[i]
}
x<-cbind(as.numeric(t(x1)),as.numeric(t(y1)),as.numeric(t(z1)))
x<-rotate3d(x,pi/2.8,0.9,0.9,0.5)
@
\begin{figure}[!h] 
\scalebox{0.4}{ 
<<echo=FALSE, results=hide, grdevice=rgl.Sweave, fig=TRUE, width=4, height=4,units = "cm",resolution=100>>=
bg3d("white")
as<-ashape3d(x,alpha=0.03)
plot(as,col=c(4,4,4))
@
<<echo=FALSE, results=hide, grdevice=rgl.Sweave, fig=TRUE, width=4, height=4,units = "cm",resolution=100>>=
as<-ashape3d(x,alpha=0.35)
bg3d("white")
plot.ashape3d(as,col=c(4,4,4))
@
<<echo=FALSE, results=hide, grdevice=rgl.Sweave, fig=TRUE, width=4, height=4,units = "cm",resolution=100>>=
as<-ashape3d(x,alpha=0.5)
bg3d("white")
plot.ashape3d(as,col=c(4,4,4))
@ 
}
\caption{From left to right, $\alpha$-shapes of a point cloud in $\mathbb{R}^3$ for increasing values of $\alpha$.}
\label{fig:ahull3}
\end{figure}





\section{Implementation}\label{sec:imp}
The \proglang{R} package \pkg{alphashape3d} comprises functions
to compute, represent and display the $\alpha$-shape of a given
sample of points in three-dimensional Euclidean space. We restrict ourselves to point sets in $\mathbb{R}^3$ because we are mainly motivated by the applications of the $\alpha$-shape in 3D, even though the definition of the $\alpha$-shape can be generalized to higher dimensions (increasing the difficulty of the implementation).

The main function in the package is \code{ashape3d}, that implements in \proglang{R} the
algorithm specified by \cite{Edels94}. The $\alpha$-shape is
computed from the three-dimensional Delaunay triangulation of the
point set. Subsection~\ref{sec:del} describes the computation of
that triangulation, and Section~\ref{sec:ashape} describes the
computation of the $\alpha$-shape. Subsection~\ref{sec:graph} gives
details about the three-dimensional graphical representation of
the $\alpha$-shape. Subsection~\ref{sec:clustering} describes functions to compute and visualize the connected components of the $\alpha$-shape. Subsection~\ref{sec:other} describes other important features of the $\alpha$-shape that can be computed with functions in the library \pkg{alphashape3d}.


\subsection[Delaunay triangulation in 3D. The package geometry]{Delaunay triangulation in 3D. The package \pkg{geometry}}\label{sec:del}
The computation of the $\alpha$-shape is closely related to the
construction of the Delaunay triangulation of the given point
set. \cite{Edels83} makes precise the relationship
that exists between these two geometric structures in the bidimensional case by proving that the $\alpha$-shape is a subgraph of the Delaunay triangulation. This simplifies the computation of the $\alpha$-shape since we only have to consider the edges of the Delaunay triangulation as candidates to form the $\alpha$-shape. The relationship between $\alpha$-shape and Delaunay triangulation is also decisive in $\mathbb{R}^3$. The problem of triangulation in $\mathbb{R}^3$ arises in the
decomposition of three-dimensional objects, for example, in solid
modeling. The Delaunay triangulation is an essential geometric
structure with a large number of applications, such as mesh
generation and cluster analysis, crystallography, metallurgy,
image processing, etc. For in-depth discussions of these problems
we refer the reader to \cite{Auren91} and \cite{Preparata85}.

Similarly to the two-dimensional case, the Delaunay triangulation
in $\mathbb{R}^3$ is defined as the dual of the Voronoi diagram
(or, tessellation). Recall that the Voronoi diagram of a finite
sample of points is the partition of space into cells such that
each cell comprises the points which are closer to one particular
sample point than to any other sample point. In the simplest,
two-dimensional case, the data are a sample of points in the
plane, which are the Voronoi point sites. Each point site has
associated a closed and convex Voronoi cell, defined by an open
and convex Voronoi region, Voronoi edges and Voronoi vertices, as
illustrated in Figure~\ref{fig:dual}.  In $\mathbb{R}^3$,
  each Voronoi cell is defined by a Voronoi region that is a
  three-dimensional convex polyhedron, Voronoi facets, Voronoi
  edges, and Voronoi vertices.  The dual complex Delaunay
  ``triangulation'' consists of Delaunay tetrahedra and their
  triangular faces, edges and vertices, hence may more properly
  be called a ``tetrahedralization''.

  
An important feature in the Delaunay triangulation is that the
circumsphere of each tetrahedron includes no other point sites
(empty sphere property). The centers of these empty circumspheres
are just the vertices of the Voronoi diagram, see Figure~\ref{fig:dual}. \cite{Okabe00} provide an extensive discussion
on the properties of Voronoi diagrams, Delaunay triangulations
and their many applications in computational geometry. It is
  should be noted that for a set of $n$ points in
  $\mathbb{R}^{3}$ the number of Delaunay tetrahedra generally is
  proportional to $n^{2}$.


<<echo=false, results=hide>>=
x1<-c(0.5915,0.6230,0.9689,0.8248,0.9392,0.8156,0.2050,0.9757,0.0957,0.4139)
y1<-c(0.472,0.619,0.304,0.197,0.716,0.575,0.507,0.574,0.996,0.893)
x<-cbind(x1,y1)
@ 

\begin{figure}[!h]
\centering
\scalebox{0.5}{
<<fig=TRUE,echo=false,results=hide>>=lset(col.whitebg())
par(mfrow=c(1,1))
print(plot(0,type="n",xlim=c(0,1),ylim=c(0,1),xlab="",ylab="",axes=F))
print(plot(delvor(x),col=1:3,xlab="",ylab="",add=T))
@
<<echo=FALSE,results=hide>>= 
# Delaunay triangulation in R3 and circumsphere
# This function is to choose a not too large circumsphere
# We consider the circumspheres contained in [0,1]^3
DTcube<-function(v){
return(apply(cbind(v[,1],1-v[,1],v[,2],1-v[,2],v[,3],1-v[,3]),1,min))
}
# x..........data
n<-50
x<-cbind(runif(n),runif(n),runif(n))
# delaunayn return a m*4 matrix (m tetrahedra with 4 indexed vertices abcd)
tc<-delaunayn(x)
# Coordenates a
v1<-x[tc[,1],]
v2<-x[tc[,2],]
v3<-x[tc[,3],]
v4<-x[tc[,4],]

nv1<-apply(v1^2,1,sum)
nv2<-apply(v2^2,1,sum)
nv3<-apply(v3^2,1,sum)
nv4<-apply(v4^2,1,sum)


Dx<-numeric()
Dy<-numeric()
Dz<-numeric()
ct<-numeric()
a<-numeric()
for (i in 1:dim(v1)[1]){
tetra<-rbind(v1[i,],v2[i,],v3[i,],v4[i,])
nor<-c(nv1[i],nv2[i],nv3[i],nv4[i])
Dx[i]<-det(cbind(nor,tetra[,2:3],rep(1,4)))
Dy[i]<--det(cbind(nor,tetra[,c(1,3)],rep(1,4)))
Dz[i]<-det(cbind(nor,tetra[,1:2],rep(1,4)))
ct[i]<-det(cbind(nor,tetra[,1:3]))
a[i]<-det(cbind(tetra[,1:3],rep(1,4)))
}
# Circumspheres with centers (ctx,cty,ctz) and radius rad
ctx<-0.5*Dx/a
cty<-0.5*Dy/a
ctz<-0.5*Dz/a
rad<-0.5*sqrt(Dx^2+Dy^2+Dz^2-4*a*ct)/abs(a)
# We determine which circumspheres are contained in [0,1]^3
d1<-DTcube(cbind(ctx,cty,ctz))
inS<-rad<d1
# we choose an "intermediate" one to draw (not too large, not too big)
# cualSp1<-which(rad==max(rad[inS]))
cualSp1<-which(rad==sort(rad[inS])[floor(length(rad[inS])/2)])
sp1<-c(ctx[cualSp1],cty[cualSp1],ctz[cualSp1],rad[cualSp1])
@ 
<<echo=FALSE, results=hide, grdevice=rgl.Sweave, fig=TRUE, width=4,height=4,resolution=100,units = "cm">>=
rgl.viewpoint(60)
rgl.light(120,60)
rgl.bg(col="white")
tetramesh(tc,x,alpha=0.1,color="red")  
tetramesh(matrix(tc[cualSp1,],nr=1,nc=4),x, alpha=1,color="red",add=TRUE,clear=FALSE)
rgl.spheres(sp1[1],sp1[2],sp1[3],sp1[4],alpha=0.5,color="gray")
points3d(x[,1],x[,2],x[,3],color=1)
@  
}
\caption{The left panel shows the Voronoi diagram of a set
    of point in $\mathbb{R}^2$: each point has an associated
    closed and convex Voronoi polygon (whose boundary is outlined
    in green), delimited by Voronoi edges abutting on Voronoi
    vertices; the corresponding Delaunay triangulation is drawn
    in red. The right panel shows the Delaunay triangulation of a
    uniform random sample of size $n=50$ drawn from the unit cube
    in $\mathbb{R}^3$: the Delaunay diagram comprises tetrahedra
    and their triangular faces, edges and vertices; a
    tetrahedron's circumsphere, drawn in gray, contains no data
    points besides those at its vertices.}
\label{fig:dual}
\end{figure}



In \proglang{R}, the Delaunay triangulation in $\mathbb{R}^3$ can
be computed with the package \pkg{geometry} \citep{geometry},
which makes the \code{qhull} library (\url{www.qhull.org})
available in \proglang{R}. The function \code{qhull} computes
convex hulls, Delaunay triangulations, Voronoi vertices,
farthest-site Voronoi vertices, and half-space intersections.
\cite{barber96} describe the Quickhull algorithm and review
literature on the subject exhaustively. Discussion on efficient
methods for the computation of Delaunay triangulation and Voronoi
diagrams can be found in \cite{Auren00} and references therein.

The function \code{delaunayn} in package \pkg{geometry} plays an
important role in the computation of the $\alpha$-shape described
in Section \ref{sec:ashape}. Given a sample of points in $\mathbb{R}^3$, it returns for each tetrahedron in
the triangulation the indices of the sample points defining the
tetrahedron.

\subsection[The function ashape3d]{The function \code{ashape3d}}\label{sec:ashape}
<<echo=FALSE, results=hide>>= 
n<- 4000
r1<- 0.5
r2<- 2
alp1<- 0.3
alp2<- 0.5
@ 
Here we describe the function \code{ashape3d}, included in
  the library \pkg{alphashape3d}, that implements the algorithm
  to construct the three-dimensional $\alpha$-shape in
  \proglang{R}. The function \code{ashape3d} computes the $\alpha$-shape of a given sample $\mathcal{X}_n$ in $\mathbb{R}^3$ for given values of $\alpha > 0$. As an example to illustrate the use of the function we consider a point cloud of size $n=\Sexpr{n}$ within two linked tori, see Figure~\ref{fig:ahull4}.  
  
<<echo=false, results=hide>>=
n <- 4000
T1 <- rtorus(n/2, 0.5, 2)
T2 <- rtorus(n/2, 0.5, 2, ct = c(2, 0, 0), rotx = pi/3)
x <- rbind(T1, T2)
points3d(x, col = 4)
@  
 \begin{figure} [!h]
\begin{center} 
\scalebox{0.5}{
<<echo=FALSE, results=hide, grdevice=rgl.Sweave, fig=TRUE, width=4, height=4,units = "cm",resolution=100>>=
rgl.viewpoint(20)
rgl.light(120,60)
bg3d("white")
rgl.points(x, col = 4)
@ 
}

\vspace{-1.5cm}
\end{center} 
\caption{Point cloud of size $n=\Sexpr{n}$ within two linked tori.}
\label{fig:ahull4}
\end{figure} 
  
  Using function \code{rtorus}, we
  generated a uniform random sample of size $2000$ in each of two
  tori with minor radius $r=0.5$ and major radius $R=2$. The
  computation of the $\alpha$-shape requires that the input
  points be in the so-called \emph{general position} (no
  quadruplet of points lies on the same plane, no quintuplet lies
  on the same sphere, and, for any particular $\alpha$, the
  smallest sphere through any two, three, or four points has
  radius different from $\alpha$).  The function determines
  whether the given points are in such general position, and it
  gives the user the option of slightly disturbing their
  coordinates to remove the degeneracy and compute the
  $\alpha$-shape, see Section~\ref{sec:comp}.

<<echo=true,eval=FALSE>>=
n <- 4000
T1 <- rtorus(n/2, 0.5, 2)
T2 <- rtorus(n/2, 0.5, 2, ct = c(2, 0, 0), rotx = pi/3)
x <- rbind(T1, T2)
points3d(x, col = 4)
@
<<echo=FALSE, results=hide>>=
rgl.close()
@ 

We compute the $\alpha$-shape for $\alpha=\Sexpr{alp1}$ and $\alpha=\Sexpr{alp2}$.

<<echo=true>>=
alphashape3d <- ashape3d(x, alpha = c(0.3, 0.5))
class(alphashape3d)
names(alphashape3d)
@

The output of the function is an object of class 'ashape3d'.  The components \code{x} and \code{alpha} store the input information.  For each simplex (tetrahedron, triangle, edge or vertex) in the three-dimensional Delaunay triangulation there is a single interval so that the simplex is a face of the $\alpha$-shape if and only if $\alpha$ is contained in this interval. Moreover, see Table I in \cite{Edels94}\footnote{The  end-points of these sub-intervals, $\rho_T$, $\underline{\mu}_T$ and
  $\overline{\mu}_T$ defined in \cite{Edels94}, are stored in columns \code{rhoT}, \code{muT} and \code{MuT}, respectively}, each interval can be broken into three parts that classify a simplex as an interior, regular or singular simplex of the $\alpha$-complex. As defined in \cite{Edels94}, a simplex in the $\alpha$-complex is interior if it does not belong to the boundary of the $\alpha$-shape.
  A simplex in the $\alpha$-complex is regular if it is part of the boundary of the $\alpha$-shape and bounds some higher-dimensional simplex in the $\alpha$-complex. A simplex in the $\alpha$-complex is singular if it is part of the boundary of the $\alpha$-shape but does not bounds any higher-dimensional simplex in the $\alpha$-complex. This classification allows us to identify the simplices that define the boundary of the $\alpha$-shape. 

Throughout this paper, numerical results are listed as
\proglang{R} would produce them by default, irrespective of
whether all the digits reported are substantively significant.


<<echo=true>>=
head(alphashape3d$tetra)
@


For each tetrahedron of the 3D Delaunay triangulation, the matrix \code{tetra} stores the indices of the sample points defining the tetrahedron (columns 1 to 4), a value \code{rhoT} that defines the intervals for which the tetrahedron belongs to the $\alpha$-complex (column 5) and for each $\alpha$ a value (1 or 0) indicating whether the tetrahedron belongs to the $\alpha$-shape (columns 6 to last). Thus, for the sample in Figure~\ref{fig:ahull4b} (left), the tetrahedron defined by the points with indexes $(\Sexpr{alphashape3d$tetra[1,1]}, \Sexpr{alphashape3d$tetra[1,2]}, \Sexpr{alphashape3d$tetra[1,3]}, \Sexpr{alphashape3d$tetra[1,4]})$ belongs to the $\alpha$-shape for $\alpha>\Sexpr{round(alphashape3d$tetra[1,5],4)}$.


<<echo=true>>=
head(alphashape3d$triang)
@

For each triangle of the 3D Delaunay triangulation, the matrix \code{triang} stores the indices of the sample points defining the triangle (columns 1 to 3), a value (1 or 0) indicating whether the triangle is on the convex hull (column 4), a value (1 or 0) indicating whether the triangle is attached or unattached\footnote{See nomenclature of \cite{Edels94}} (column 5), values \code{rhoT}, \code{muT} and \code{MuT} that define the intervals for which the triangle belongs to the $\alpha$-complex (columns 6 to 8) and for each $\alpha$ a value (0, 1, 2 or 3) indicating, respectively, that the triangle is not in the $\alpha$-shape or it is interior, regular or singular (columns 9 to last). 

<<echo=true>>=
head(alphashape3d$edge)
@
	

For each edge of the 3D Delaunay triangulation, the matrix \code{edge} stores the indices of the sample points defining the edge (columns 1 and 2), a value (1 or 0) indicating whether the edge is on the convex hull (column 3), a value (1 or 0) indicating whether the edge is attached or unattached (column 4), values \code{rhoT}, \code{muT} and \code{MuT} that define the intervals for which the edge belongs to the $\alpha$-complex (columns 5 to 7) and for each $\alpha$ a value (0, 1, 2 or 3) indicating, respectively, that the edge is not in the $\alpha$-shape or it is interior, regular or singular (columns 8 to last).


<<echo=true>>=
head(alphashape3d$vertex)
@

For each sample point, the matrix vertex stores the index of the point (column 1), a value (1 or 0) indicating whether the point is on the convex hull (column 2), values \code{muT} and \code{MuT} that define the intervals for which the point belongs to the $\alpha$-complex (columns 3 and 4) and for each $\alpha$ a value (1, 2 or 3) indicating, respectively, if the point is interior, regular or singular (columns 5 to last).



 
\subsection[Graphical representation of the alpha--shape in 3D]{Graphical representation of the $\bm{\alpha}$--shape in 3D}\label{sec:graph}

Graphical visualization is an essential part of data analysis and statistical modelling. The function \code{plot.ashape3d} (S3 method for class
'ashape3d') performs 3D visualization of the $\alpha$-shape. 

<<echo=true, results=hide>>= 
rgl.viewpoint(20)
rgl.light(120, 60)
bg3d("white")
plot(alphashape3d, col = c(4, 4, 4), indexAlpha = "all")
@
<<echo=false, results=hide>>=
rgl.close()
@ 


The input must be an object of class 'ashape3d'. The argument \code{col} is a vector of colour numbers for the triangles, edges and vertices composing the $\alpha$-shape (the default colour is red). The argument \code{indexAlpha} can be a single value or a vector specifying the indexes of \code{alphashape3d$alpha} to be used for representing the $\alpha$-shape. If \code{indexAlpha="all"} or \code{indexAlpha="ALL"} then the function opens a new rgl device for each value of $\alpha$ in \code{alphashape3d$alpha}.  Other arguments are available. The argument \code{transparency} controls the transparency properties of the  $\alpha$-shape. Its value ranges from zero (transparent) to one (opaque). The scene and appearance of shapes, backgrounds and bounding box objects can be controlled by functions and parameters in package \pkg{rgl}, see \cite{rgl}. The package
\pkg{rgl} adds three-dimensional, real-time visualization
functionality to the \proglang{R} programming environment. Figure~\ref{fig:ahull4b} shows snapshots of the above call to \code{plot.ashape3d}. 

\begin{figure}[!h] 
\begin{center} 
\scalebox{0.5}{


<<echo=FALSE, results=hide, grdevice=rgl.Sweave, fig=TRUE, width=4, height=4,units = "cm",resolution=100>>=
rgl.viewpoint(20)
rgl.light(120,60)
bg3d("white")
plot.ashape3d(alphashape3d,indexAlpha=1, col = rep(4,3))
@

<<echo=FALSE, results=hide, grdevice=rgl.Sweave, fig=TRUE, width=4, height=4,units = "cm",resolution=100>>=
rgl.viewpoint(20)
rgl.light(120,60)
bg3d("white")
plot.ashape3d(alphashape3d,indexAlpha=2, col = rep(4,3))
@ 
}

\vspace{-1.5cm}
\end{center} 
\caption{Snapshots from \code{plot.ashape3d} representing the $\alpha$-shape of the point cloud for $\alpha=\Sexpr{alp1}$ (middle) and $\alpha=\Sexpr{alp2}$ (right).}
\label{fig:ahull4b}
\end{figure}

\subsection[Connected components of the alpha--shape]{Connected components of the $\bm{\alpha}$-shape}\label{sec:clustering}

The library \pkg{alphashape3d} includes the function \code{components_ashape3d} that computes the connected components of the $\alpha$-shape of a given point cloud in $\mathbb{R}^3$ and identifies the component that each sample point belongs
  to. We find this function potentially useful for partitioning
  point clouds into clusters. See Chapter 2 in \cite{Marchette04}
  for a discussion on the usefulness of the $\alpha$-shape for
  clustering in the planar case. The visualization of the
  connected components of the $\alpha$-shape provides clues about
  the reality of clusters in the data set. Owing to the
  characteristics of the $\alpha$-shape, these clusters may have
  rather irregular shapes. Therefore, the connected components
  defined based on the $\alpha$-shape may be more meaningful and
  accurate than those produced by classification algorithms that
  are entirely based on distance calculations.


In our implementation the $\alpha$-shape is represented as a
  set of tetrahedrons, triangles, edges and vertices. This
  representation facilitates the computation of the adjacency
  matrix of the vertices. Using this information, we can then
  identify the connected components of the $\alpha$-shape using
  an algorithm inspired by the strongly connected components
  algorithm described in \cite{tarjan72}. Our algorithm is a
  modification of depth-first search (DFS) to label all the
  vertices of a component and then to jump to another component
  when needed.

For the example whose results are depicted in
  Figure~\ref{fig:comp}, we compute the connected components
  corresponding to the $\alpha$-shapes for $\alpha=0.3$ and
  $\alpha=0.5$ stored in \code{alphashape3d}.

<<echo=TRUE, results=hide>>=
comp <- components_ashape3d(alphashape3d, indexAlpha = "all")
@ 
 
If  \code{indexAlpha} is a single value then the function returns a vector \code{v} of length equal to the sample size. For each sample point \code{i}, \code{v[i]} represents the label of the connected component to which the point belongs (for isolated points, \code{v[i]=-1}). Otherwise, \code{components_ashape3d} returns a list of vectors describing the connected components of the $\alpha$-shape for each selected value of $\alpha$. 

<<echo=TRUE>>=
table(comp[[1]])
table(comp[[2]])
@ 

This shows that the $\alpha$-shape for $\alpha=0.3$ has two
  connected components with $2000$ sample points each, and that
  the $\alpha$-shape for $\alpha=0.5$ has only one connected
  component. The function \code{plot.ashape3d}, described in Subsection \ref{sec:graph}, displays the connected components of the $\alpha$-shape in different colours by setting the argument \code{byComponents = TRUE}. The following code produces Figure~\ref{fig:comp}.

<<echo=TRUE, results=hide>>=
rgl.viewpoint(20)
rgl.light(120, 60)
bg3d("white")
plot(alphashape3d, byComponents = TRUE, indexAlpha = "all")
@ 
<<echo=false, results=hide>>=
rgl.close()
@ 


\begin{figure} 
\begin{center} 
\scalebox{0.5}{
<<echo=FALSE, results=hide, grdevice=rgl.Sweave, fig=TRUE, width=4, height=4,units = "cm",resolution=100>>=
rgl.viewpoint(20)
rgl.light(120,60)
bg3d("white")
plot(alphashape3d, byComponents = TRUE, indexAlpha = 1)
@ 
<<echo=FALSE, results=hide, grdevice=rgl.Sweave, fig=TRUE, width=4, height=4,units = "cm",resolution=100>>=
rgl.viewpoint(20)
rgl.light(120,60)
bg3d("white")
plot(alphashape3d, byComponents = TRUE, indexAlpha = 2)
@ 
}

\vspace{-1cm}
\end{center} 
\caption{Connected components of the $\alpha$-shape of the point cloud for $\alpha=\Sexpr{alp1}$ (left) and $\alpha=\Sexpr{alp2}$ (right).}
\label{fig:comp}
\end{figure}

\subsection[Volume and other attributes of the  alpha-shape]{Volume and other attributes of the  $\bm{\alpha}$-shape}\label{sec:other}
Here we describe other functions in the library \pkg{alphashape3d} that compute the values of several
  attributes of the $\alpha$-shape. The function \code{volume_ashape3d} calculates the volume of the $\alpha$-shape of a point cloud. The input must be an object of class 'ashape3d'. As described before, the argument \code{indexAlpha} can be a single value or a vector specifying the indexes of \code{alphashape3d$alpha} to be considered. For our example, we compute the volume of the $\alpha$-shape for $\alpha=\Sexpr{alp1}$.

<<echo=TRUE>>=
volume_ashape3d(alphashape3d, indexAlpha = 1)
@ 
<<echo=FALSE, results=hide>>=
volt<-volume_ashape3d(alphashape3d, indexAlpha = 1)
@ 

We can also compute the volume of each connected component of the $\alpha$-shape separately, by setting the argument \code{byComponents = TRUE}.

<<echo=TRUE>>=
volume_ashape3d(alphashape3d, indexAlpha = 1, byComponents = TRUE)
@ 

These add up to $\Sexpr{round(volt,4)}$, which is the total volume of the
  $\alpha$-shape in Figure~\ref{fig:comp} (left).

The function \code{inashape3d} checks whether one or several
  points belong to the interior of the $\alpha$-shape. For
example, the point $(-2.5,2.5,0)$ does not belong to any of
the $\alpha$-shapes computed above.

<<echo=TRUE>>=
inashape3d(alphashape3d, indexAlpha = "all", c(-2.5, 2.5, 0))
@ 

The following code produces Figure~\ref{fig:in1}. We have considered a sequence of points in the line $y=-x$ ($z=0$). After using the function \code{inashape3d} we represent in red the points that do not belong to the $\alpha$-shape and in green the points that belong to the $\alpha$-shape for $\alpha=\Sexpr{alp1}$.

<<echo=TRUE, results=hide>>=
np <- 50
x <- seq(-2.5, 2.5, length = np)
points <- cbind(x, -x, rep(0, np))
in3d <- inashape3d(alphashape3d, indexAlpha = 1, points = points)
rgl.viewpoint(20)
bg3d("white")
plot(alphashape3d, col = c(4, 4, 4), indexAlpha = 1, transparency = 0.2)
colours <- ifelse(in3d, "green", "red")
rgl.points(points, col = colours)
@ 

\begin{figure}[!h] 
\begin{center} 
\scalebox{0.5}{
%<<echo=FALSE, results=hide, grdevice=rgl.Sweave, fig=TRUE, %width=4, height=4,units = "cm",resolution=100, outputtype=pdf, %pdf=TRUE>>=
%rgl.viewpoint(20)
%bg3d("white")
%plot(alphashape3d, index=1,col=c(4,4,4))
%rgl.spheres(-1,0,0,0.1, col = 2)
%@
<<echo=FALSE, results=hide, grdevice=rgl.Sweave, fig=TRUE, width=4, height=4,units = "cm",resolution=100>>=
rgl.viewpoint(20)
bg3d("white")
plot(alphashape3d, indexAlpha = 1, col = c(4, 4, 4), transparency = 0.2)
colours <- ifelse(in3d, "green", "red")
rgl.points(points, col = colours)
@
}

\vspace{-1cm}
\end{center} 
\caption{In blue, $\alpha$-shape of the input point cloud for $\alpha=\Sexpr{alp1}$. In red, points in the line $y=-x$ ($z=0$) that do not belong to the $\alpha$-shape. In green, points in the line $y=-x$ ($z=0$) that belong to the $\alpha$-shape.}
\label{fig:in1}
\end{figure}

The algorithm used to determine whether a given point $p$
is inside the $\alpha$-shape is an extension of the
point-in-polygon ray-casting algorithm. The idea is to cast a ray
from $p$ in a randomly chosen direction and compute the
intersections between the ray and the \emph{regular} triangles of
the $\alpha$-shape. Recall that, according to the
nomenclature of \cite{Edels94}, a triangle is regular if it
  belongs to the boundary of the $\alpha$-shape and is a face of
  one of its tetrahedra. If there is an odd number of
  intersections between the ray and the regular triangles, then
  the tested point $p$ is inside the $\alpha$-shape. If there is
  an even number of intersections, then $p$ is outside the
  $\alpha$-shape. To determine whether a half ray intersects a
  triangle, we compute the intersection of four half-spaces,
  which is considerably faster than testing whether $p$ belongs
  to any of the tetrahedra that form the $\alpha$-shape.

\ 

Finally, the function \code{surfaceNormals} calculates the normal vectors to the triangles in the boundary of the $\alpha$-shape. For the considered example, we compute the normal vectors  for the $\alpha$-shape with  $\alpha=\Sexpr{alp1}$.

<<echo=TRUE>>=
normv <- surfaceNormals(alphashape3d, indexAlpha = 1)
class(normv)
names(normv)
head(normv$normals)
head(normv$centers) 
@ 

The function returns an object of class 'normals'.  The component \code{normals} is a three-column matrix with the euclidean coordinates of the normal vectors (the norm of each vector is equal to the area of its associated triangle). The component \code{centers} is a three-column matrix with the euclidean coordinates of the centers of the triangles that form the boundary of the $\alpha$-shape. The normal vectors can be represented by setting the argument \code{display = TRUE} in the function \code{surfaceNormals}.




\section[Computational details]{Computational details}\label{sec:comp}

\textit{About the general position assumption}

For the computation of the $\alpha$-shape, the input points in function \code{ashape3d} must be in general position. Otherwise, the function \code{ashape3d} prints an error message reporting that the general position assumption is not satisfied. By setting the argument \code{pert = TRUE} the function \code{ashape3d} applies a slight perturbation to the input points in case they are nor in general position. Both, the original points and the perturbed data, are stored in components \code{x} and \code{xpert} of the output object, respectively.

\

\textit{Exporting as OFF files}

Object File Format (.off) files are commonly used to represent the geometry of an object. OFF files represent collections       of planar polygons with possibly shared vertices. They are specially useful to describe polyhedra and many 3D graphics programs use this format for input or output. An object of class 'ashape3d' can be easily exported as an OFF file. Each OFF file begins with the keyword ``OFF''. The next line includes the number of vertices, faces, and edges of the object. Next, the coordinates of the vertices are listed and following these are the face descriptions. The following code saves the $\alpha$-shape computed in our example for $\alpha=\Sexpr{alp1}$ as an OFF file. OFF files can be visualized and manipulated quite easily using 3D viewing programs.

<<echo=TRUE, results=hide>>=
offFilename <- "alphashape3d.off"
write("OFF", file = offFilename, append = FALSE, sep = " ")
aux <- alphashape3d$triang
tr <- aux[aux[, 9] == 2 | aux[, 9]==3, c("tr1", "tr2", "tr3")]
write(c(dim(alphashape3d$x)[1], dim(tr)[1], 0), file = offFilename, 
append = TRUE, sep = " ")
write(t(alphashape3d$x), file = offFilename, ncolumns = 3, 
append = TRUE, sep = " ")
write(t(cbind(rep(3, dim(tr)[1]), tr - 1)), 
file = offFilename, ncolumns = 4, append = TRUE, sep = " ")
@ 




\

\textit{Software}

The \pkg{alphashape3d} package is available from the Comprehensive \proglang{R} Archive Network at the url \url{http://CRAN.R-project.org/package=alphashape3d}. This document was generated with version 1.1 of the package.



%\bibliographystyle{jss}
\bibliography{biblio}
\end{document}
